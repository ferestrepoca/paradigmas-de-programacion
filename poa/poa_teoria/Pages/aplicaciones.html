<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Programacion Orientada a Aspectos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
</head>
<body>

<section class="page-header">
    <h1 class="project-name">Programacion Orientada a Aspectos</h1>
    <h2 class="project-tagline"></h2>
	
	<a href="../index.html" class="btn">Inicio</a>
	<a href="historia.html" class="btn">Historia</a>
	<a href="filosofia.html" class="btn">Filosofía del Paradigma</a>
	<a href="evolucion.html" class="btn">Conceptos Claves</a>
	<a href="ventajasydesventajas.html" class="btn">Ventajas y desventajas</a>
	<a href="lenguajes.html" class="btn">Lenguajes</a>
	<a class="btn btn-actual">Aplicaciones</a>
	<a href="presentaciones.html" class="btn">Presentaciones</a>
	<a href="practicas.html" class="btn">Practica</a>
	<a href="ejemplos.html" class="btn">Ejemplos</a>
</section>
<section class="main-content">
    <h1><b> APLICACIONES DE ESTE PARADIGMA</b></h1>
    <UL type=disk>
        <li> <h2><ins>Manejo de transacciones</ins></h2>
            <p align="justify"> Una transaccion en un sistema de gestion de bases de datos (SGBD), es un conjunto de ordenes que se ejecutan formando una unidad de trabajo, es decir, una forma indivisible o atomica.</p>
            <p align="justify">La estructura de una transacción usualmente viene dada según el modelo de la transacción, estas pueden ser planas (simples) o anidadas.	</p>
            </br>
            <img width="500" height="300" src="https://github.com/ferestrepoca/paradigmas-de-programacion/blob/master/poa/poa_teoria/Images/trans2.png?raw=true" hspace="150"> </img>
            <p align="justify">El Manejo Transaccional es uno de los temas cruciales en cuanto a requerimientos para
                aplicaciones empresariales. Esta motivación surge debido a que en todo sistema empresarial
                nos interesa mantener la integridad de nuestra información, con esto en mente es que surge el
                tema de transacciones.</p>
            <p align="justify">En la figura podemos observar un método de servicio que ejecuta llamadas a más de un DAO,
                y a su vez cada DAO modifica el estado de la base de datos al escribir y/o modificar su
                información.</p>
            <p align="justify">El objetivo de una transacción es ejecutar todas las líneas de código de nuestro método y
                guardar finalmente la información en un repositorio, por ejemplo en nuestro caso, una base de
                datos. Esto se conoce como commit de nuestra transacción.</p>
            <p align="justify">Si por alguna razón algo fallara en nuestro método de Servicio, se daría marcha atrás a los
                cambios realizados en la base de datos. Esto se conoce como rollback.</p>
            <p align="justify">Lo anterior permite que nuestra información, ya sea que se una única base de datos o no, esté
                íntegra, y no exista posibilidad de datos corruptos por errores o fallas en la ejecución de
                nuestros métodos.</p>
            <p align="justify"> Spring:AOP e Hibernate han implementado el manejo transaccional a partir de la Programación Orientada a Aspectos debido al acceso de datos y funciones transversales</p>
            </br>
		</li>
        <LI> <h2><ins>Sincronización</ins></h2>
            <p align="justify"> La sincronización expuesta aquí se basa en los procesos y nos referimos a ella por el hecho de que esta otorga varias técnicas de coordinación de hilos que se ejecutan en forma simultánea y procesos para poder completar una determinada tarea con el objetivo de que estas se ejecuten en un orden establecido y que no se dé lugar a eventos inesperados.</p>


            <p align="justify">Mencionamos a continuación en forma general los tipos de sincronización existentes: Barrier, Bloqueo/Semáforo (Lock/Semaphore), Unión de hilos (Thread join), Exclusión Mutua (Mutex), Monitores (Monitors), Sincronización no bloqueante (Non-blocking synchronization), Rendezvous, Contadores de eventos y secuenciadores (Event counters and sequencers).</p>
            </p>
            <p align="justify">Con esto nos ahorramos el hecho de colocar en cada método la palabra clave lock, el cual garantiza la ejecución de una sección crítica de código o exclusión mutua también denominada, una sección crítica de código es aquella que no permite ser ejecutada al mismo tiempo, debido a que puede darse el caso de que haya lectura sucia o que al mismo tiempo dos o más hilos de ejecución traten de modificar el valor de una variable, por lo tanto se bloquea dicha sección de código en forma exclusiva en un ambiente concurrente, no permitiendo de esta forma a que otro hilo trate de ejecutar esa sección crítica en un instante dado.</p>

            <p align="justify">Además al evitar repetir esta palabra clave nos aseguramos de no repetir código por un lado y por otro de separar la funcionalidad básica del aspecto de sincronización.</p>

            <p align="justify">En la definición del aspecto de sincronización expuesto más arriba, podemos decir que existen dos métodos, el primero llamado OnEntry el cual habilita la entrada a la ejecución del código de sección crítica y se utiliza la clase Monitor que provee un mecanismo para sincronizar el acceso a los objetos y el segundo método llamado OnExit, que se usa para realizar el abandono de la sección crítica de la ejecución del código, por lo tanto se invoca al método Exit de la clase Monitor.</p>

            <img width="500" height="400" src="https://github.com/ferestrepoca/paradigmas-de-programacion/blob/master/poa/poa_teoria/Images/sincro.png?raw=true" hspace="150"> </img>
            </br>
            </br></LI>
        <LI> <h2><ins>Perfiles</ins></h2>
            <p align="justify"> Tomaremos como ejemplo la Extensión de UML usando Perdiles:</p>
            <p align="justify">En la actualidad, UML (Unified Modeling Language) es uno de los lenguajes de modelado más
                utilizados para el diseño de sistemas. Este lenguaje permite especificar, construir, visualizar y
                documentar artefactos de un sistema de software de manera sencilla.</p>
            <p align="justify">Muchas veces UML es demasiado general y no es lo suficientemente expresivo para modelar
                elementos específicos de un dominio particular. En estas situaciones es necesario, extender UML.</p>
            <p align="justify">Por esta razón, UML estándar incluyó un mecanismo para extender y adaptar UML a diferentes
                dominios y plataformas: el “Perfil UML” (“UML Profile”)</p>
            <p align="justify">Para realizar la extensión UML 2.0  incluyó la definición del paquete “Profile”. Éste
                paquete incluye los mecanismos para redefinir estereotipos, valores etiquetados y restricciones.</p>
            <p align="justify">La propuesta de extensión del perfil, no permite modificar al metamodelo existente, sino adaptar al
                metamodelo existente, agregando constructores propios para un dominio particular.</p>
            <p align="justify">Los estereotipos son especificados como metaclases, los valores etiquetados como metaatributos y
                los perfiles como una clase de paquete. </p>
            </br></LI>
        <LI> <h2><ins>Manejo de Memoria</ins></h2>
            <p align="justify"> Ya que la principal tarea de la memoria consiste en llevar un registro de las partes de memoria que se estén utilizando y las que no , con el fin de asignar espacio en memoria a los procesos cuando éstos la necesiten y liberándola cuando terminen, así como administrar el intercambio entre la memoria principal y el disco. El uso de este paradigma de programación ahorra el uso de memoria al no guardar multiples veces las mismas funciones y código en diferentes clases, sino que al aprovechar el fundamento de su paradigma, accede a esta información de manera más eficiente a un sólo bloque de código y no necesita tener código de ejecución sino que es ejecutado bajo ciertas reglas.</p>

        <LI> <h2><ins>Control de Acceso o Seguridad</ins></h2>
            <p align="justify"> Debido al uso eficiente del paradigma dentro del uso de las cuentas y perfiles, también afecta directamente el uso de los controles de acceso y la seguridad. Ya que la aplicación se mantiene generalmente igual para cada usuario, solamente difiere su acceso (o no acceso). Por lo que sería rebundante replicar código para cada sesión o la certificación o no del usuario.</p>
            <p align="justify">Además, al haber solamente un bloque de código de datos importantes y confidenciales, habrá menos riesgo de encontrar dichos datos. Y es más sencillo controlar el acceso a esos datos si solamente están confinados a un control de acceso y no de manera múltiple.</p>
            </br></LI>
        <LI> <h2><ins>Logging</ins></h2>
            <p align="justify"> De manera similar al Control de Acceso, el <i>Logging</i> es una forma menos generalizada, pero cumple con las mismas características. </p>
            </br></LI>
        <LI> <h2><ins>Manejo de Excepciones</ins></h2>
            <p align="justify"> A través del enfoque de AOP, es posible interceptar las llamadas a los métodos y determinar cuando estos han generado una excepción para posteriormente aplicar la política de manejo más apropiada. Estas políticas puede ser parte del propio aspecto de gestión de excepciones. Como en el caso del registro de eventos, la implementación de este aspecto buscará reducir su implementación (y aplicación) a un atributo que decore el método cuyas posibles excepciones se quieren gestionar.</p>

            <b>Un Apropiado Soporte</b>

            <p align="justify">Al crear un mecanismo de gestión y manejo de excepciones, no deberíamos partir desde cero, ya que existe un montón de excelentes productos y frameworks que nos simplificarían esta tarea. Para este caso, emplearé los Microsoft Libraries, en particular el Exception Handling Application Block; sin embargo el enfoque de AOP y de este framework que he venido presentado permite emplear cualquier otra librería.</p>

            <b>Implementación</b>

            <p align="justify">Es importante que si no han leido las primeras partes de esta serie de artículos, aprovechen este momento para hacerlo, sobre todo la parte 1. A partir de este momento mis explicaciones considerarán que el conocimiento y los detalles técnicos explicados en esa parte ya son conocidos.</p>

            <p align="justify">El primer paso es crear el atributo (Attribute) que decorará las clases/interfaces para capturar su ejecución e inyectar el código de manejo de excepciones. Nuestro atributo se llamará ExceptionHandlingAttribute y extiende de InterceptableAttribute, la clase base en el framework de AOP que sirve para definir atributos de intercepción. </p>
		</LI>
		</br></br>
		<li> <h2><ins>Software que emplea programación orientada a aspectos.</ins></h2>  
            </br>
			<b>WebSphere Application Server (WAS)</b>						
            <p align="justify">
				Es una plataforma de IBM que actúa como un servidor de aplicaciones diseñado para configurar, operar e integrar aplicaciones empresariales.
				WebSphere se distribuye en distintas ediciones donde cada edición soporta diferentes funcionalidades y usan AspectJ internamente para
				aislar las funcionalidades asociadas a cada edición.
			</p></br>
			<b>JBoss Application Server (JBoss AS)</b>						
            <p align="justify">
				Es un servidor de aplicaciones Java EE. Es un software libre y de código abierto, como está basado en java se puede usar en cualquier 
				sistema operativo donde haya una máquina virtual de java. El núcleo de JBoss está integrado con programacion orientada a aspectos donde 
				se usa principalmente para desplegar servicios tales como seguridad y administración de transacciones.
			</p></br>
			<b>Oracle TopLink</b>						
            <p align="justify">
				Es un framework para almacenar objetos Java en una base de datos relacional (Object-Relational mapping) o convertir estos objetos en formato 
				XML. TopLink logra altos niveles de persistencia y transparencia usando Spring AOP (Componente del framework Spring usado para  aplicar AOP).
			</p>			

		</li>
	
    </UL>
	<footer class="site-footer">
		<span class="site-footer-owner"><a href="https://github.com/ProgramacionOrientadaAspectos/POA_teoria">Programacion Orientada a Aspectos</a> is maintained by <a href="https://github.com/ProgramacionOrientadaAspectos">ProgramacionOrientadaAspectos</a>.</span>
		<span class="site-footer-credits">This page was created by Diego Rojas, Gustavo Galvis y Dorian Tovar.</span>
	</footer>
</section>

<hr size="8px" color="#151157" />
</body>

</body>
</html>
