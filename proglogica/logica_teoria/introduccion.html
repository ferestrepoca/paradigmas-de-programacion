<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <title>Programación Lógica</title>

  <!-- CSS  -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection" />
  <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection" />
</head>

<body>
  <nav class="custom-blue" role="navigation">
    <div class="nav-wrapper container"><a id="logo-container" href="" class="brand-logo">Prog. Lógica</a>
      <ul class="right hide-on-med-and-down">
        <li><a href="">Introducción</a></li>
        <li><a href="lang.html">Programación Lógica</a></li>
        <li><a href="lenguajes.html">Lenguajes Lógicos</a></li>
        <li><a href="present.html">Presentaciones y referencias</a></li>
      </ul>
      <ul id="nav-mobile" class="side-nav">
        <li><a href="">Introducción</a></li>
        <li><a href="lang.html">Programación Lógica</a></li>
        <li><a href="lenguajes.html">Lenguajes Lógicos</a></li>
        <li><a href="present.html">Presentaciones y referencias</a></li>
      </ul>
      <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
    </div>
  </nav>
  <div class="main-content">
    <div class="cell border-box-sizing text_cell rendered">
      <div class="prompt input_prompt">
      </div>
      <div class="inner_cell">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h1 id="Introducción">Introducción</h1>
        </div>
      </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
      <div class="prompt input_prompt">
      </div>
      <div class="inner_cell">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h4 id="Paradigma-de-programación">Paradigma de programación:</h4>
          <p>
            <center><i>"Es el conjunto de principios subyacentes que dan forma al estilo de un lenguaje de programación."</i></center>
          </p>
          <p align="right">Concepts, Techniques, and Models of Computer Programming.</p>
          <p><img src="imagenes/paradigms.png" style="max-width:100%; width: 50%; max-width: none"></p>
          <p>Indica un método mediante el cual se deben resolver uno a varios problemas claramente delimitados.</p>
          <p>Representa un enfoque particular o filosofía para diseñar soluciones.</p>

        </div>
      </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
      <div class="prompt input_prompt">
      </div>
      <div class="inner_cell">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h3 id="Imperativo-vs-Declarativo:">Imperativo vs Declarativo:</h3>
          <p>Dentro de los paradigmas de programación existen 2 grandes grupos: que son los <strong>Declarativos</strong> y
            los <strong>Imperativos</strong>. Las características principales de ellos se ven en el siguiente gráfico.</p>
          <p><img src="imagenes/impdec.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
          <p>
            <p>
              Los desarrolladores web, pasan sus días dando instrucciones a las computadoras. Estas instrucciones generalmente implican
              algo de entrada (ej. una solicitud de una página web), algo de lógica (ej. obtener el contenido correcto de
              una base de datos) y algo de salida (ej. enviar el contenido al navegador solicitante). Este proceso de decir
              a un ordenador <b>cómo</b> realizar una tarea, es lo que comúnmente llamamos "programación",
              pero es sólo un subconjunto de programación: la programación <b>imperativa</b>.
            </p>
          </p>
          <p>
            <p>
              Hay otro tipo de programación, la programación <b>declarativa</b>. Con la programación declarativa decimos
              a una computadora <b>qué</b>, no cómo realizar una tarea. Describimos el resultado que queremos y los detalles
              de cómo lograrlo se dejan al intérprete de lenguaje. Este cambio sutil en el enfoque de la programación tiene
              amplios efectos sobre la forma en la cual construimos software.
            </p>
          </p>
          <p>
            <p>
              Los lenguajes declarativos tienden a desvanecerse en el fondo de la programación, en parte porque están más cerca de cómo
              interactuamos naturalmente con la gente. Si estás hablando con un amigo y quieres un sándwich, normalmente
              no le das a tu amigo instrucciones paso a paso sobre cómo preparar el sándwich. Si lo hiciera, se sentiría
              como la programación de su amigo. En cambio, es mucho más probable que hable sobre el resultado que desea,
              como <i>"Por favor, hazme un sandwich"</i> (o, tal vez, <i>"Sudo hazme un sandwich"</i>). Si
              su amigo está dispuesto y es capaz de seguir esta instrucción, entonces traducirán la frase <i>"Hazme un sandwich"</i>              en una serie de pasos, como encontrar un pan, quitar dos rebanadas, aplicar coberturas, etc.
            </p>
            <img src="imagenes/impdec002.PNG" style="max-width:100%; width: 30%; max-width: none"></p>

        </div>
      </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
      <div class="prompt input_prompt">
      </div>
      <div class="inner_cell">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h3 id="Historia">Historia</h3>
          <p>
            Uno de los precursores de la lógica matemática y, en consecuencia, de la programación lógica fue Aristóteles (384-322 a.C.)
            con su teoría silogística. Esta teoría estudia una clase particular de implicaciones con dos premisas y una conclusión.
            También fue tratada por los filósofos contemporáneos a Aristóteles y largamente estudiada en siglos posteriores,
            aunque no se produjeron innovaciones de interés hasta el siglo XVII con los trabajos de René Descartes y Gottfried Leibnitz.
          </p>
          <p>
            Dos siglos después el matemático y lógico británico George Boole (1815-1864) dio un paso importante en el sistema
            de razonamiento aristotélico poniendo en relación la lógica y el álgebra. Los trabajos de Boole fueron modificados 
            y ampliados mas tarde por otros matemáticos y lógicos como Jevon, Pierce, Schroeder y Huntington, entre otros.
          </p>
          <p>
            Llegamos así a finales del siglo XIX y principios del XX con la revolución de la fundamentacion de las Matemáticas gracias
            a los trabajos de Frege, Cantor, Peano, Russell, Whitehead, entre otros, que marcan el periodo más apasionante
            y de mayor actividad en la historia de la lógica matemática.
          </p>
          <p>
            En la mitad del siglo XX descubrimos que de forma paralela al desarrollo de la lógica se ha producido un espectacular avance
            de las llamadas “máquinas de calcular”, avance sobre el que reflexiona Alan Turing en un articulo titulado <i>“¿Pueden pensar las máquinas?”</i>,
            publicado en 1950 y que podemos dar como punto de partida de lo que después se llamará Inteligencia Artificial.
          </p>
          <img src="imagenes/historia.PNG" style="max-width:100%; width: 80%; max-width: none">
          <p>
            El primer momento en el que se usa la lógica matemática para representar y ejecutar programas es en <b>1930</b>            cuando aparece como una caracteristica de los <i>cálculos lamba</i> desarrollados por <b>Allonzo Church</b>.
          </p>
          <p>
            Sin embargo, la primera propuesta para usar la <i>forma causal de la lógica</i> para representar programas de
            cómputo fue propuesta por <b>Cordell Green</b> en <b>1969</b>. Esto utilizó una axiomatización de un subconjunto
            de <b>LISP</b> (es una familia de lenguajes de programación de computadora de tipo multiparadigma con una larga
            historia y una sintaxis completamente entre paréntesis), junto con una representación de una relación de entrada-salida,
            para calcular la relación simulando la ejecución del programa en LISP.
          </p>
          <p>
            Por otro lado, Fyster y Elcock's Absys emplearon una combinación de ecuaciones y <i>cálculos lamba</i> en un
            lenguaje de programación asercional que no impone restricciones en el orden en que se realizan las operaciones.
          </p>
          <p>
            A principios de los 70's en la Universidad de Aix-Marseille I (Marsella, Francia) fue ideado un lenguaje de programación
            por los estudiantes <b>Alain Colmerauer y Philippe Roussel</b>. Éste nació de un proyecto que no
            tenía como objetivo la traducción de un lenguaje de programación, sino la clasificación algorítmica de lenguajes
            naturales. <b>Alain Colmerauer y Robert Pasero</b> trabajaban en la parte del procesado del lenguaje natural
            y <b>Jean Trudel y Philippe Roussel</b> en la parte de deducción e inferencia del sistema. Interesado por el
            método de resolución <b>SL</b>, Trudel persuadió a <b>Robert Kowalski</b> para que se uniera al proyecto, dando
            lugar a una versión preliminar del lenguaje Prolog a finales de <b>1971</b> y apareciendo la versión definitiva
            en <b>1972</b>. Esta primera versión de Prolog fue programada en ALGOL W.
          </p>
          <p>
            A <b>Finales de los 70's</b> <b>Robert Kowalski</b> crea el método de prueba por refutación que emplea el algoritmo
            de unificación como mecanismo de base y permite la extracción de respuestas <b>SLD (Selective Linear Definite clause resolution)</b>.
          </p>
          <p>
            Inicialmente se trataba de un lenguaje totalmente interpretado hasta que en <b>1983</b>, David H.D. Warren desarrolló
            un compilador capaz de traducir Prolog en un conjunto de instrucciones de una máquina abstracta denominada <b>Warren Abstract Machine</b>,
            o abreviadamente, WAM. Desde entonces Prolog es un lenguaje semi-interpretado.
          </p>
        </div>
      </div>
    </div>
  </div>
  <footer class="page-footer custom-orange">
    <div class="footer-copyright">
      <div class="container">
        Creado por estudiantes del curso Lenguajes de Programación de la Universidad Nacional de Colombia.
      </div>
    </div>
  </footer>


  <!--  Scripts-->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
  <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="js/materialize.js"></script>
  <script src="js/init.js"></script>

</body>

</html>