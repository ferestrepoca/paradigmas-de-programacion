<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
    <title>Programación Lógica</title>

    <!-- CSS  -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection" />
    <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection" />
</head>

<body>
<nav class="custom-blue" role="navigation">
    <div class="nav-wrapper container"><a id="logo-container" href="introduccion.html" class="brand-logo">Prog. Lógica</a>
        <ul class="right hide-on-med-and-down">
            <li><a href="introduccion.html">Introducción</a></li>
            <li><a href="">Programación Lógica</a></li>
            <li><a href="lenguajes.html">Lenguajes Lógicos</a></li>
            <li><a href="present.html">Presentaciones y referencias</a></li>
        </ul>
        <ul id="nav-mobile" class="side-nav">
            <li><a href="introduccion.html">Introducción</a></li>
            <li><a href="">Programación Lógica</a></li>
            <li><a href="lenguajes.html">Lenguajes Lógicos</a></li>
            <li><a href="present.html">Presentaciones y referencias</a></li>
        </ul>
        <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
    </div>
</nav>
<div class="main-content">
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h1 id="Programación-Lógica">Programación Lógica</h1>
                <h5>Índice de contenido:</h5>
                <ol>
                    <li><a href="#Filosofía">Filosofía del paradigma</a></li>
                    <li><a href="#QuéEs">¿Qué es?</a></li>
                    <ol>
                        <li><a href="#QuéResuelve">¿Qué trata de resolver?</a></li>
                        <li><a href="#Características">Características</a></li>
                    </ol>
                    <li><a href="#LógicaProposicional">Lógica Proposicional</a></li>
                    <ol>
                        <li><a href="#LógicaPrimerOrden">Lógica de primer orden</a></li>
                        <li><a href="#CláusulasDeHorn">Cláusulas de Horn</a></li>
                    </ol>
                    <li><a href="#ResoluciónSLD">Resolución SLD</a></li>
                    <li><a href="#Backtracking">Backtracking</a></li>
                    <li><a href="#ProblemaNReinas">Problema de las N reinas</a></li>
                    <li><a href="#VentajasyDesventajas">Ventajas y desventajas</a></li>
                    <ol>
                        <li><a href="#Ventajas">Ventajas</a></li>
                        <li><a href="#Desventajas">Desventajas</a></li>
                    </ol>
                    <li><a href="#Lenguajes">Lenguajes</a></li>
                    <ol>
                        <li><a href="#ProLog">ProLog</a></li>
                        <li><a href="#Mercury">Mercury</a></li>
                        <li><a href="#CLP-(FD)">CLP(FD)</a></li>
                        <li><a href="#Godel">Gödel</a></li>
                        <li><a href="#miniKanren">miniKanren</a></li>
                        <li><a href="#SequenceL">SequenceL</a></li>
                    </ol>
                    <li><a href="#Aplicaciones">Aplicaciones</a></li>
                </ol>

                <div class="cell border-box-sizing text_cell rendered">
                    <div class="prompt input_prompt">
                    </div>

                    <div class="inner_cell">
                        <div class="text_cell_render border-box-sizing rendered_html">
                            <h2 id="Filosofía">Filosofia del paradigma</h2>
                            <p>
                                La mayoría de los lenguajes de programación se basan en la teoría lógica de primer orden, aunque también incorporan algunos
                                comportamientos de orden superior, en este sentido, destacan los lenguajes funcionales
                                ya que se basan en el Calculo Lambda, es la única teoría lógica de orden superior.
                            </p>
                            <h5 class="frase">
                                <center><i>"Modelar problemas por medio de la abstracción, utilizando un sistema de lógica formal que permite llegar
                                    a una conclusión por medio de hechos y reglas"</i></center>
                            </h5>
                            <h5 class="frase">
                                <center><i>"Aplicación de reglas de la lógica para inferir conclusiones a partir de datos."</i></center>
                            </h5>

                        </div>
                    </div>
                </div>
                <h2 id="QuéEs">¿Qué es?</h2>
                <p>
                    Paradigma de programación basado en la lógica de primer orden. La programación lógica estudia el uso de la lógica para el
                    planteamiento de problemas y el control sobre las reglas de inferencia para alcanzar la solución
                    automática.
                </p>
                <p>
                    La programación lógica, junto con la funcional, forma parte de lo que se conoce como Programación Declarativa, es decir la
                    programación consiste en indicar como resolver un problema mediante sentencias, en la Programación
                    Lógica, se trabaja en una forma descriptiva, estableciendo relaciones entre entidades, indicando
                    no como, sino que hacer, entonces se dice que la idea esencial de la programación lógica es
                </p>
                <p><img src="imagenes/001.png"></p>
                <p>Se puede ver como una deducción controlada.</p>
                <p><strong>Lógica (programador):</strong> hechos y reglas para representar conocimiento.</p>
                <p><strong>Control (interprete):</strong> deducción lógica para dar respuestas (soluciones).</p>
                <h3 id="QuéResuelve">¿Qué trata de resolver?</h3>
                <p>Dado un problema S, saber si la afirmación A es solución o no del problema o en que casos lo es. Además
                    queremos que los métodos sean implantados en maquinas de forma que la resolución del problema se
                    haga de forma automática</p>
                <p><strong>La programación lógica construye base de conocimientos mediante reglas y hechos.</strong></p>
                <h3 id="Características">Características del Paradigma</h3>                
                    <li>Unificación de términos.</li>
                    <li>Mecanismos de inferencia automática.</li>
                    <li>Recursion como estructura de control básica.</li>
                    <li>Visión lógica de la computación.</li>                
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h1 id="LógicaProposicional">Lógica Proposicional</h1>
                <p>También llamada <b><i>lógica de enunciados</i></b>: toma como elemento básico las frases declarativas
                    simples o proposiciones. Su estructura está dada por:</p>
                <p><img src="imagenes/propo001.PNG" style="max-width:100%; width: 80%; max-width: none"></p>
                <p>
                    Es un sistema formal cuyos elementos más simples representan proposiciones, y cuyas constantes lógicas, llamadas conectivas
                    lógicas, representan operaciones sobre proposiciones, capaces de formar otras proposiciones de mayor
                    complejidad.
                </p>
                <p>
                    La lógica proposicional trata con sistemas lógicos que carecen de cuantificadores, o variables interpretables como entidades.
                    En lógica proposicional si bien no hay signos para variables de tipo entidad, sí existen signos para
                    variables proposicionales (es decir, que pueden ser interpretadas como proposiciones con un valor
                    de verdad definido), de ahí el nombre proposicional. La lógica proposicional incluye además de variables
                    interpretables como proposiciones simples signos para conectivas lógicas, por lo que dentro de este
                    tipo de lógica puede analizarse la inferencia lógica de proposiciones a partir de proposiciones,
                    pero sin tener en cuenta la estructura interna de las proposiciones más simples.
                </p>
                <p><b>Proposiciones:</b> Elementos de una frase que constituyen por sí solos una unidad de comunicación
                    de conocimientos y pueden ser considerados verdaderos o falsos.</p>
                <p><b>Proposición Simple:</b> <i>“Pepito es humano”</i>.</p>
                <p><b>Proposición Compuesta:</b> <i>“Pepito es hombre y pepita es mujer”</i>.</p>
                <p><img src="imagenes/propo002.PNG" style="max-width:100%; width: 80%; max-width: none"></p>

            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="LógicaPrimerOrden">Lógica de primer orden</h3>
                <p>También llamada <b><i>lógica de predicados</i></b>: es un sistema deductivo basado en un lenguaje lógico
                    matemático formal. Su estructura esta dada por:</p>
                <p><img src="imagenes/predi.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>Incluye proposiciones lógicas, predicados y cuantificadores.</p>
                <p>Más expresiva de la Lógica proposicional.</p>
                <ul>
                    <li>¿Qué se afirma? (predicado o relación)</li>
                    <li>¿De quién se afirma? (objeto)</li>
                </ul>
                <p>Es un sistema formal diseñado para estudiar la inferencia en los lenguajes de primer orden.1 Los lenguajes
                    de primer orden son, a su vez, lenguajes formales con cuantificadores que alcanzan sólo a variables
                    de individuo, y con predicados y funciones cuyos argumentos son sólo constantes o variables de individuo.
                    La lógica de primer orden tiene el poder expresivo suficiente para definir a prácticamente todas
                    las matemáticas.</p>

            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="CláusulasDeHorn">Cláusulas de Horn</h3>
                <p>Secuencia de literales que contiene a lo sumo uno de sus literales positivos (disyunción de literales).
                    Esto es un ejemplo de una cláusula de Horn, y abajo se indica una fórmula como esta también puede
                    reescribirse de forma equivalente como una implicación:</p>
                <p><img src="imagenes/horn001.PNG" style="max-width:100%; width: 30%; max-width: none"></p>
                <ul>
                    <li><b>Cláusula ‘definite’:</b> Cláusula de Horn con exactamente un literal positivo.</li>
                    <li><b>Hecho:</b> Cláusula ‘definite’ sin literales negativos.</li>
                    <li><b>Cláusula objetivo:</b> Sin ningún literal positivo (consulta).</li>
                </ul>
                <center> antecedente &rarr; consecuente

                    <b><i>"Si es verdad el antecedente, entonces es verdad el consecuente"</i></b></center>
                <p>En Prolog Se escribe primero el consecuente luego el antecedente.</p>
                <p><b>Ej:</b> Estructura de clúasulas de Horn:
                    <img src="imagenes/horn002.PNG" style="max-width:100%; width: 50%; max-width: none"> Estructura de
                    clásulas de Horn en Prolog:
                    <img src="imagenes/horn003.PNG" style="max-width:100%; width: 50%; max-width: none"></p>

            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="ResoluciónSLD">Resolución SLD (Selective Linear Definite clause resolution)</h3>
                <p>
                    El nombre <b>"SLD resolution"</b> fue dado por Maarten van Emden para la regla de inferencia sin
                    nombre introducida por <b>Robert Kowalski</b>. Su nombre deriva de la resolución de <b>SL</b>, que
                    es a la vez sonido y refutación completa de la forma clausal sin restricciones de la lógica. <b>"SLD"</b>                        significa <b>"SL resolution with Definite clauses"</b>.
                </p>
                <p>
                    En ambos, SL y SLD, <b>"L"</b> representa el hecho de que una prueba de resolución se puede restringir
                    a una secuencia lineal de cláusulas:
                </p>$$C_{1}, C_ {2}, \cdots, C_{l}$$
                <p>
                    Donde la "cláusula superior" \(C_ {1}\), es una cláusula de entrada, y cada otra cláusula \(C_{i + 1} \) es una solución de cuyos
                    padres es la cláusula anterior \(C_ {i} \). La prueba es una refutación si la última cláusula \(C_{l} \), es la cláusula vacía.
                </p>
                <p>
                    En SLD, todas las cláusulas son una secuencia <b>cláusulas objetivo</b> y el otro padre es una <b>cláusula de entrada</b>.
                    En la resolución SL, el otro padre es una cláusula de entrada o una cláusula ancestral anterior en
                    la secuencia.
                </p>
                <p>
                    Tanto en SL como en SLD, "S" representa el único literal resuelto en cualquier cláusula \(C_ {i} \), es aquel que es seleccionado
                    únicamente por una regla de selección o función de selección. En la resolución SL, el literal seleccionado
                    está restringido a uno que ha sido introducido recientemente en la cláusula. En el caso más simple,
                    tal función de selección de último en entrar primero en salir puede especificarse por el orden en
                    el que se escriben los literales, como en Prolog. Sin embargo, la función de selección en la resolución
                    SLD es más general que en la resolución SL y en Prolog. No hay ninguna restricción sobre el literal
                    que se puede seleccionar.
                </p>
                <h3 id="Backtracking">Backtracking</h3>
                <p>
                    En lenguajes de programación como Fortran, Pascal, C o Java, las instrucciones se ejecutan normalmente en orden secuencial,
                    es decir, una a continuación de otra, en el mismo orden en que están escritas, que sólo varía cuando
                    se alcanza una instrucción de control (un bucle, una instrucción condicional o una transferencia).
                </p>
                <p>
                    Los programas en Prolog se componen de <b>cláusulas de Horn</b> que constituyen reglas del tipo <i>"modus ponendo ponens"</i>,
                    es decir, <b><i>"Si es verdad el antecedente, entonces es verdad el consecuente"</i></b>. No obstante,
                    la forma de escribir las cláusulas de Horn es al contrario de lo habitual. <i>Primero se escribe el consecuente y luego el antecedente</i>.
                    El antecedente puede ser una conjunción de condiciones que se denomina secuencia de objetivos. Cada
                    objetivo se separa con una coma y puede considerarse similar a una instrucción o llamada a procedimiento
                    de los lenguajes imperativos. En Prolog no existen instrucciones de control. Su ejecución se basa
                    en dos conceptos: la <b>unificación</b> y el <b>backtracking</b>.
                </p>
                <img src="imagenes/tree001.PNG" style="max-width:100%; width: 50%; max-width: none">
                <p>
                    Gracias a la <b>unificación</b>, cada objetivo determina un <b>subconjunto de cláusulas susceptibles de ser ejecutadas</b>.
                    Cada una de ellas se denomina <b>punto de elección</b>. Prolog selecciona el <b>primer punto de elección</b>                        y sigue ejecutando el programa hasta determinar si el objetivo es
                    <font color="green">verdadero</font> o
                    <font color="red">falso</font>.
                </p>
                <p>
                    En caso de ser falso entra en juego el <b>backtracking</b>, que consiste en deshacer todo lo ejecutado
                    situando el programa en el mismo estado en el que estaba justo antes de llegar al <b>punto de elección</b>.
                    Entonces se toma el siguiente punto de elección que estaba pendiente y se repite de nuevo el proceso.
                    Todos los objetivos terminan su ejecución bien en éxito (<font color="green">"verdadero"</font>), bien en fracaso (
                    <font color="red">"falso"</font>).
                </p>
                <p>
                    A continuación veremos un ejemplo de backtracking en caso de que todos los objetivos son
                    <font color="red">falsos</font>.
                </p>
                <p><img src="imagenes/tree002.PNG" style="max-width:100%; width: 50%; max-width: none">
                    <img src="imagenes/tree003.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>Selecciona el primer punto de elección.</p>
                <p><img src="imagenes/tree004.PNG" style="max-width:100%; width: 50%; max-width: none">
                    <img src="imagenes/tree005.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>Si encuentra un objetivo
                    <font color="red">falso</font> realiza <b>backtracking</b> hasta el punto de elección anterior, y continua.</p>
                <p><img src="imagenes/tree006.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>Repite el mismo procedimiento y en caso de no encontrar objetivo
                    <font color="red">verdadero</font>, y no tener más puntos de elección que recorrer devuelve
                    <font color="red">falso</font> como resultado de la consulta.</p>
                <p><img src="imagenes/tree007.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>En caso de que todos alguno de los objetivos sea
                    <font color="green">verdadero</font> este es el recorrido.</p>
                <p><img src="imagenes/tree008.PNG" style="max-width:100%; width: 50%; max-width: none">
                    <img src="imagenes/tree009.PNG" style="max-width:100%; width: 50%; max-width: none">
                    <img src="imagenes/tree010.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <h3 id="ProblemaNReinas">El problema de las N reinas: (Backtracking)</h3>
                <p> El problema consiste en un tablero de ajedrez que tiene NxN celdas,
                    necesitamos colocar N reinas de tal manera que ninguna reina ataque a otra reina.
                    Una reina puede atacar horizontalmente, verticalmente y diagonalmente.</p>
                <p><img src="imagenes/queen001.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p> Inicialmente tenemos NxN celdas sin ataques donde necesitamos colocar N reinas.
                    Colocamos la primera reina en una celda (i, j), de modo que ahora el número de celdas
                    no atacadas se reduzca, y la cantidad de reinas que se ubicarán es N-1.
                    Colocamos la próxima reina en alguna celda no atacada. De nuevo, esto reduce
                    el número de celdas sin ataque, y el número de reinas que se colocarán
                    se convierte en N-2. Continuamos haciendo esto, siempre y cuando se cumplan
                    las siguientes condiciones:
                <li style = "margin-left:3em"> El número de celdas sin ataque no es 0.</li>
                <li style = "margin-left:3em"> El número de reinas a colocar no es 0.</li>
                </p>
                <p><img src="imagenes/queen002.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p> Finalmente, si el número de reinas que se colocan se convierte en 0,
                    entonces se terminó, encontramos una solución. Pero si el número de celdas
                    desatendidas se convierte en 0, entonces debemos retroceder, es decir,
                    eliminar la última reina colocada de su celda actual, y colocarla en alguna otra celda.
                    Hacemos esto recursivamente.
                </p>
                <p><img src="imagenes/queen003.PNG" style="max-width:10%; width: 30%; max-width: none"></p>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h1 id="Conceptos-clave-del-paradigma">Conceptos clave del paradigma</h1>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="Hechos">Hechos</h3>
                <p>
                    Expresión atómica (declaración, cláusula o proposición) que se formula de la forma \(P(t_{1}, ..., t_{n})\),
                    indicando que se verifica el predicado <b>P</b> sobre los objetos \(t_{1}, ..., t_{n}\).</p>
                <p><img src="imagenes/hecho.PNG" style="max-width:100%; width: 30%; max-width: none"></p>
                <p>
                    Sobre estas expresiones se puede definir el concepto de <u><i>aridad</i></u> como la cantidad de
                    objetos presentes en su declaración, a partir de este concepto se pueden clasificar los hechos como:
                </p>
                <ul>
                    <li><b>Enunciado:</b> Aridad = 0. <i> Ejm: Verdadero.</i></li>
                    <li><b>Propiead: </b> Aridad = 1. <i> Ejm: humano(Pepito), animal(Perro).</i></li>
                    <li><b>Relación: </b> Aridad > 1. <i> Ejm: padre(Homero, Bart), aprobar(Juan, Lenguajes de Programación).</i></li>
                </ul>
                <p>
                    Los hechos son utilizados para declarar verdades desde el principio de la ejecucción de un programa,
                    y el conjunto de estos hechos se denomina como base de conocimientos.
                </p>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="Reglas">Reglas</h3>
                <p>
                    Conjunto de proposiciones lógicas escritas como <a href="#CláusulasDeHorn">clausulas de Horn</a>
                    que permiten inferir el valor de verdad de nuevas proposiciones,
                    permitiendo ampliar la base de conocimientos, a la vez que son utilizadas para definir el dominio del problema. </p>
                <p><img src="imagenes/regla.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="Consultas">Consultas</h3>
                <p>
                    Proposición construida con el propósito de ser demostrada/desmentida o de encontrar
                    el conjunto de valores que la convierten verdadera. En las consultas se especifica el problema a resolver.
                    Partiendo deque los humanos son mortales y de que Pepito es humano (ejemplos anteriores),
                    deducimos que <i>Pepito es mortal</i>.
                </p>
                <p><img src="imagenes/consulta.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="Recursión">Recursión</h3>
                <p>La recursividad puede ser tratada de una manera más eficaz si se piensa en que hace el algoritmo recursivo
                    que se piensa aplicar, en vez de cómo hacerlo. Para esto se usará la modularidad, la cual se basa
                    en separar el problema en otros más pequeños y hallar la solución a estos para luego unirlos, como
                    es ususal en la programación lógica.</p>
                <p>Lo que se ha estado mostrando hasta ahora es, este sistema de resolver problemas de la programación lógica
                    mediante la modularidad, entonces, ¿cómo puede ser aplicada ésta en la recursión?</p>
                <p>Si nuestro problema es obtener el área de un cuadrado, lo que se debe hacer no es separar esta área en
                    una de un triángulo o un círculo, sino en las áreas de otros cuadrados, por lo cual se puede dar
                    el valor del área del cuadrado con las medidas mínimas y de ahí empezar a llamar recursivamente la
                    función con medidas mayores a ésta. Por ejemplo:</p>
                <p>El área de un cuadrado de área de 2 unidades cuadradas es igual a cuatro veces el área de un cuadrado
                    de 1 unidad cuadrada.
                </p>
                <p>De esta manera se pueden obtener resultados de un problema con solo definir los casos base y de ahí realizar las
                    operaciones recursivamente.
                </p>
                <p>En un ámbito más matemático ésta idea puede ser utilizada para resolver operaciones sencillas como es
                    el caso de las sumatorias o factoriales, en general cualquier operación que requiera información
                    del resultado que generan valores inferiores al dado. Un ejemplo de ésto podría ser el hallar las
                    potencias de dos dado el exponente en la función, lo cual puede ser hallado con el siguiente programa
                    de Prolog.</p>
                <p><img src="imagenes/recurs.PNG" style="max-width:100%; width: 25%; max-width: none"></p>

            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h3 id="Ejemplo">Ejemplo:</h3>
                <p>Un conjunto de hechos constituye un programa (la forma más simple de programa lógico) que puede ser visto
                    como una base de datos que describe una situación. Por ejemplo, el Programa 1 refleja la base de
                    datos de las relaciones familiares que se muestran en el siguiente gráfico.
                    <img src="imagenes/ej0011.PNG" style="max-width:100%; width: 50%; max-width: none">
                    <img src="imagenes/ej002.PNG" style="max-width:100%; width: 50%; max-width: none"></p>
                <p>
                    Todos los hechos de este programa son hechos de base (sin variables), pero también se pueden introducir hechos con variables
                    como axiomas,por ejemplo: \(suma(0, X, X)\). En ellos, las variables se consideran cuantificadas universalmente.
                    Es decir, &#8704;\(x\) \(suma(0, x, x)\).
                </p>
                <p>
                    Al igual que el hecho es_mujer(sarah) establece la verdad de la sentencia "Sarah es mujer", el hecho \(suma(0, X, X)\) establece
                    la verdad para cualquier valor que pueda tomar la variable, es decir, nos dice que "para todo término
                    x, la suma de 0 con x es x" . Equivale a un conjunto de hechos de base como serían: \(suma(0, 1, 1)\),
                    \(suma(0, 2, 2)\), etc.
                </p>
                <p>
                    Una vez que se tiene el programa describiendo una situación, se pueden hacer consultas para obtener información acerca de
                    él. Por ejemplo, podemos hacer consultas al Programa 1 del tipo siguiente:
                </p>
                <p><img src="imagenes/ej003.PNG" style="max-width:100%; width: 40%; max-width: none"></p>

            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h2 id="VentajasyDesventajas">Ventajas y Desventajas del uso de este paradigma</h2>
                <h5 id="Ventajas">Ventajas</h5>
                <li>Descripciones independientes de la implementación (unificación semántica).</li>

                <li>Puede mejorarse la eficiencia modificando el componente de control sin tener que modificar la lógica
                    del algoritmo.</li>
                <li>Base de conocimiento fácilmente escalable.</li>
                <li>Relaciones multipropósito.</li>
                <li>Expresión simple y precisa de los problemas.</li>
                <li>Generación rápida de prototipos e ideas complejas.</li>
                <li>Sencillez en la implementación de estructuras complejas.</li>
                <li>Potencia.</li>

                <h5 id="Desventajas">Desventajas</h5>
                <li>Dependiendo del problema a solucionar, la implementación y el motor de inferencia,
                    puede llegar a ser extremadamente ineficiente.</li>
                <li>Pocas y muy específicas áreas de aplicación.</li>
                <li>Existen muy pocas herramientas de depuración, en su mayoría poco efectivas.</li>
                <li>En problemas reales, es poco utilizado.</li>
                <li>Si el programa no contiene suficiente información para responder una consulta
                    la respuesta puede ser una que se preste para malentendidos.</li>
                <li>Inferencia limitada por su base de conocimiento.</li>
            </div>
        </div>
    </div>
    <div class="cell border-box-sizing text_cell rendered">
        <div class="prompt input_prompt">
        </div>
        <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h1 id="Aplicaciones:">Aplicaciones:</h1>
                <ol>
                    <li>Desarrollo de aplicaciones de inteligencia artificial.</li>
                    <li>Prueba de teoremas de forma automática, donde un programa genera nuevos teoremas sobre una teoría
                        existente.</li>
                    <li>Construcción de Sistemas expertos, donde un Sistema de información mita las recomendaciones de un
                        experto sobre algún dominio de conocimiento.</li>
                    <li>Procesamiento del lenguaje natural, donde un programa es capaz de comprender (con limitaciones) la
                        información contenida en una expresión lingüística humana.</li>
                    A continuación se presenta un ejemplo simple de procesamiento de lenguaje natural.
                    <img src="imagenes/prolog005.PNG" style="max-width:100%; width: 80%; max-width: none">
                    <li>Consultas lógicas basadas en reglas como:</li>
                    <ol>                      
                    <li>Búsquedas en bases de datos.</li>
                    <li>Sistemas de control de voz.</li> 
                    </ol>                   
                </ol>
            </div>
        </div>
    </div>
</div>
<footer class="page-footer custom-orange">
    <div class="footer-copyright">
        <div class="container">
            Creado por estudiantes del curso Lenguajes de Programación de la Universidad Nacional de Colombia.
        </div>
    </div>
</footer>


<!--  Scripts-->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="js/materialize.js"></script>
<script src="js/init.js"></script>

</body>

</html>